package io.github.idoalotofthings.vchat.model

import kotlinx.serialization.Serializable

/**
 * Recursive 2D Tree data structure for storing the queries in memory and in storage
 * @param isRoot whether the current node has any parent nodes
 * @param query the data stored in the current node
 * @param depth the depth of the current node. Generated by [QueryNode.withNodeId]
 * @param childQueryNodes List of children [QueryNode]
 * @param nodeId the unique ID of the current node. Generated by [QueryNode.withNodeId]
 */
@Serializable
data class QueryNode(
    val isRoot: Boolean = false,
    val query: Query,
    val depth: Int = 0,
    val childQueryNodes: MutableList<QueryNode> = mutableListOf(),
    val nodeId: String = ""
) {

    /**
     * Traverses the tree and returns the [QueryNode] with the id [id]
     * @param id The ID of the node
     * @param verticalDepth the vertical depth at which the node is situated
     * @return [QueryNode] with the [QueryNode.nodeId] equal to [id]
     * @throws IndexOutOfBoundsException if the node with id [id] is not in the current tree
     */
    fun getNodeAtDepthString(id: String, verticalDepth: Int): QueryNode {
        return if(verticalDepth != depth && id.length != 1) {
            val horizontalIndex = id[2].digitToInt()
            childQueryNodes[horizontalIndex].getNodeAtDepthString(id.substring(2), verticalDepth+1)
        } else {
            this
        }
    }

    override fun toString(): String {
        return "QueryNode(val = ${query.question}, depth = $depth, id = $nodeId, children = $childQueryNodes)"
    }

    /**
     * Generates the [QueryNode.depth] and [QueryNode.nodeId] for the current [QueryNode] object
     * @param nodeId The initial node ID
     * @param horizontalDepth Used for recursion
     * @param verticalDepth Used for recursion
     * @return [QueryNode] with [QueryNode.depth] and [QueryNode.nodeId] generated
     */
    fun withNodeId(nodeId: String = "0", horizontalDepth: Int = 0, verticalDepth: Int = 0): QueryNode {
        val currentId = if(isRoot) "0" else "$nodeId.$horizontalDepth"
        val newNodes = mutableListOf<QueryNode>()
        for (node in childQueryNodes.indices) {
            newNodes.add(childQueryNodes[node].withNodeId(currentId, node, verticalDepth+1))
        }
        return copy(childQueryNodes = newNodes, nodeId = currentId, depth = verticalDepth)
    }
}